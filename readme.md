# UCAS 密码分析学 谜题一 思路&脚本

## 题目及简单分析

![image-20231014100930015](C:\Users\wuhan\AppData\Roaming\Typora\typora-user-images\image-20231014100930015.png)

观察上述加密过程，我们不难发现，这其实就是一个两轮的类似多表代换的操作，区别是，这里的m_i,n_i甚至可以不是相等的，所以他是一种比常规多表代换更灵活的方式。对这种唯密文攻击我们显然不能直接倒推，直接倒推的情况是比较多的（虽然一会儿试一下就会发现变换对实际也没多少），因此要结合英文原文的概率信息进行额外的限制。

## 一些 Insight

我们知道，多轮多表代换都是线性的变换，因此一定可以变成一轮多表代换。而一轮多表代换，实际上又可以看成是一个密钥稍长的一一映射序列的加密。那么，这种类多表代换的加密是否有这样的特点呢，我们想一下，先只考虑一轮，m_1,n_1不相等，加密时是t[i] = a[i mod m_1] \* p[i] + k[i mod n_1]，我们知道当 p[i]、p[j] 加密时候使用相同的 a,k 里的值的话，他们的映射就是完全相同的，可以认为是一个单表，或者说，一个一一映射的加密。也就是说，(p,q) [(p,26)=1]完全确定 cipher = p*plain + q (mod 26) 的一一映射（虽然可能不是唯一的对应关系）。比如 t = 3 \* p + 2 （mod 26），这个就是一个固定的26->26的映射。那对于这一个类多表代换，我们就可以把它理解成一个周期性的单表代换序列。这个一一映射（单表代换）的出现周期是多长呢，我们可以想，最开始的时候映射是(a[0],p[0])，接下来a或者p到最后，再重复这个过程，其实有点像天干地支的排列过程，那多久是一个周期呢，实际上类比一下天干地支我们就知道，六十年一甲子，周期就是十天干十二地支的最小公倍数。所以这个等价的单表映射序列的周期就是m_1,n_1的最小公倍数。由于我们是两轮加密，所以要考虑一下第二轮，我们现在的目的就是找算上第二轮之后，这个单表代换序列的周期是多少。其实同理，第二轮加密自身的周期是m_2，n_2的最小公倍数，所以现在相当于，明文p，一轮加密中间产物mid，和密文t，前两者之间的周期是lcm(m_1,n_1)，后两者之间的周期是lcm(m_2,n_2)，而整体这两者之间也满足刚才那种关系，所以整个类多表代换，就可以表示成周期性的单表代换序列，周期是lcm(lcm(m_1,n_1),lcm(m_2,n_2))

好了，我知道你可能没看懂，没关系，总结一下，就是我们**这个加密，可以变成一个有周期的一一映射**，这个周期是多少其实不重要，只要知道他是有周期的就行。举个例子，有一个映射对 "qwertyuiopasdfghjklzxcvbnm"（解释一下，这里我用的映射对都是从 “abcdefg...”开始的，其意思就是a会映射到q，b会映射到w，以此类推），**假如第一个字是用这种方式加密的，那么第k个周期结束后的下一个字也是用这个映射对加密的**，解释完毕

知道了这个东西，我们该怎么求周期呢，这里就要介绍一个大家都比较熟悉的东西了，就是维吉尼亚加密，其实想一想，维吉尼亚加密也是一个有周期的一一映射，它的周期是密钥的长度。那维吉尼亚密码解密首先要猜测密钥的长度，有什么办法呢，一般来说有两种办法，重合指数攻击和Kasiski方法，这里我用Kasiski方法，为什么呢，因为我之前写过（逃

Kasiski的实现和改进可以看之前本科时候写过的[脚本]([youremailaddress/Cypto_BigProject (github.com)](https://github.com/youremailaddress/Cypto_BigProject))，这里直接Copy代码（如果对 Kasiski 改进的部分感兴趣可以看当时写的实验报告）

这里就为了行文，简单稍微说一下Kasiski的原理，就是我们知道加密映射对有周期T，那么**假如密文足够多，第k个明文和第k+nT处的明文恰好一样，那么我们就可以猜nT，虽然可能有误报，但是整体上nT附近的这种情况是出现最多的**，通过这种方式可以求得周期。详细解释看实验报告。

知道周期之后，怎么猜测明文（变换对）呢，我们就需要根据英文的统计特征进行限制。正常情况下来说，如果密文长度足够，我们可以统计同一变换对的所有密文进行分别的概率分析，但是这里密文长度只有3k，假如周期是100（当然后面看来确实没那么大），那么一个变换对只加密了三十个字母，这样看统计特征是不足以完全准确的，因此我们可以考虑结合相邻明文字母的限制，也就是英文字母的条件分布，比如p(c|ab)的意思就是ab后跟c的概率，再用这个限制一下，结果就几乎肯定是正确的了，代码放 [github](https://github.com/youremailaddress/UCASCrypto) 了，需要的自取，别忘了留个star

## 用法

python final.py K

得到最可能的 Kasiski Keylength，并修改 Setting 里对应的值

python final.py

得到最可能的若干结果，手工筛选即可（基本上是第一个）

